<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Price & Strong Buy score (last 48 hours)</title>
  <style>
    :root { --fg:#111; --muted:#666; --card:#fff; --bg:#fafafa; --brand:#2563eb; --score:#d62728; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial}
    .wrap{max-width:1080px;margin:24px auto;padding:0 12px}
    h1{font-size:20px;margin:0 0 6px}
    .meta{color:var(--muted);font-size:12px;margin-bottom:16px}
    .card{background:var(--card);border:1px solid #e5e7eb;border-radius:12px;padding:12px 12px 8px;margin:16px 0;box-shadow:0 2px 8px rgba(0,0,0,.04)}
    .toprow{display:flex;align-items:center;gap:12px;flex-wrap:wrap;margin:4px 0 8px}
    .sym{font-weight:700;letter-spacing:.3px}
    .toggles{display:flex;gap:8px;flex-wrap:wrap;font-size:12px;color:#374151}
    .toggles label{display:inline-flex;gap:4px;align-items:center;padding:2px 6px;border:1px solid #e5e7eb;border-radius:8px;background:#f8fafc}
    .ctrls{display:flex;gap:12px;align-items:center;margin-left:auto}
    .ctrls input[type="number"]{width:72px;padding:4px 6px;border:1px solid #d1d5db;border-radius:8px}
    canvas{width:100%;height:320px}
    .note{font-size:11px;color:var(--muted);margin-top:6px}
    .badge{display:inline-block;background:#111;color:#fff;border-radius:6px;padding:0 6px;font-size:11px;line-height:18px;margin-left:6px}
  </style>

  <!-- Chart.js + time adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
</head>
<body>
  <div class="wrap">
    <h1>Price & Strong Buy score (last 48 hours)</h1>
    <div class="meta">
      Left axis: price. Right axis: score (0–100). Hourly labels; 15‑minute ticks.
      <span id="lastUpdated" class="badge">Loading…</span>
    </div>
    <div id="charts"></div>
  </div>

<script>
const PALETTE = ["#2563eb","#ef4444","#10b981","#a855f7","#06b6d4","#f59e0b","#dc2626","#16a34a","#3b82f6"];
const MODELS = ["M1","M2","M3","M4","M5"];   // existing models in data.s.*
const BIN_KEY = "M2bin";                     // our new thresholded binary model id
const DEF_THRESH = 50;                       // default threshold

// Util for localStorage keys per symbol
const k = (sym) => `thresh_M2_${sym}`;

// Build a chart card per symbol
function makeCard(sym){
  const card = document.createElement('div'); card.className='card';
  const row  = document.createElement('div'); row.className='toprow';
  const symEl= document.createElement('div'); symEl.className='sym'; symEl.textContent=sym;
  const togg = document.createElement('div'); togg.className='toggles';
  const ctrls= document.createElement('div'); ctrls.className='ctrls';

  // Checkboxes for price + models + our BIN
  const items = ["price", ...MODELS, BIN_KEY];
  items.forEach((id, i) => {
    const lab = document.createElement('label');
    const cb  = document.createElement('input'); cb.type='checkbox';
    cb.checked = (id === "price" || id === "M2" || id === BIN_KEY);  // show price + M2 + BIN initially
    cb.dataset.layer = id;
    lab.appendChild(cb);
    lab.appendChild(document.createTextNode(" " + id));
    togg.appendChild(lab);
  });

  // Threshold input for M2 -> BIN
  const thLab = document.createElement('label');
  thLab.textContent = "M2 threshold:";
  const thIn = document.createElement('input');
  thIn.type='number'; thIn.min='0'; thIn.max='100'; thIn.step='0.5';
  thIn.value = localStorage.getItem(k(sym)) ?? DEF_THRESH;
  thIn.title = "Set per‑symbol threshold for (M2 > value ? 1 : 0)";
  thLab.style.marginRight = "6px";

  const thBadge = document.createElement('span'); thBadge.className='badge'; thBadge.textContent='BIN';
  ctrls.appendChild(thLab); ctrls.appendChild(thIn); ctrls.appendChild(thBadge);

  row.appendChild(symEl); row.appendChild(togg); row.appendChild(ctrls);
  card.appendChild(row);

  const c = document.createElement('canvas'); card.appendChild(c);
  const note = document.createElement('div'); note.className='note';
  note.textContent = "Toggle lines above. The black dashed line is the binary signal (0/1) derived from M2 using the threshold.";
  card.appendChild(note);

  return {card, canvas:c, controls:{thInput:thIn}, toggles:card.querySelectorAll('input[type=checkbox]')};
}

// Convert M2 to binary 0/1 per threshold, preserving nulls
function m2ToBin(arr, thresh){
  const t = Number(thresh);
  return (arr||[]).map(v => (v == null ? null : (Number(v) > t ? 1 : 0)));
}

(async function init(){
  const res = await fetch('data.json?t=' + Date.now(), {cache:'no-store'});
  const {labels, symbols, meta} = await res.json();
  document.getElementById('lastUpdated').textContent = 'Last updated (UTC): ' + (meta?.updated_utc ?? '—');

  // Build cards
  const ctr = document.getElementById('charts');
  const syms = Object.keys(symbols);
  syms.forEach((sym, si) => {
    const {card, canvas, controls, toggles} = makeCard(sym);
    ctr.appendChild(card);

    const s = symbols[sym] || {};
    const close = s.close || [];
    const scores = s.s || s.score || {}; // support either s or score namespace
    const m2 = scores.M2 || scores.m2 || [];

    // Prepare datasets
    const ds = [];
    ds.push({
      label: sym + ' price', yAxisID: 'price',
      data: close, borderColor: PALETTE[si % PALETTE.length],
      backgroundColor: PALETTE[si % PALETTE.length], pointRadius:0, tension:0.25, spanGaps:true
    });

    MODELS.forEach((m, i) => {
      const arr = (scores[m] || scores[m.toLowerCase()] || []).slice();
      ds.push({
        label: m, yAxisID: 'score', data: arr,
        borderColor: PALETTE[(i+2) % PALETTE.length],
        backgroundColor: PALETTE[(i+2) % PALETTE.length],
        pointRadius:0, tension:0.15, spanGaps:true, borderDash: m==='M2' ? [6,4] : undefined
      });
    });

    // Binary dataset on its own axis
    let binData = m2ToBin(m2, controls.thInput.value);
    const binDS = {
      label: BIN_KEY, yAxisID: 'bin', data: binData,
      borderColor: '#111', backgroundColor:'#111', borderDash:[8,6], pointRadius:0, tension:0,
      spanGaps:true
    };
    ds.push(binDS);

    // Build chart
    const ctx = canvas.getContext('2d');
    const chart = new Chart(ctx, {
      type:'line',
      data:{ labels, datasets: ds },
      options:{
        interaction:{mode:'nearest', intersect:false},
        responsive:true,
        maintainAspectRatio:false,
        scales:{
          x:{ type:'time', time:{ tooltipFormat:'HH:mm', displayFormats:{minute:'HH:mm'} },
              ticks:{ autoSkip:true, maxTicksLimit:25 }},
          price:{ position:'left', grid:{ drawOnChartArea:true } },
          score:{ position:'right', min:0, max:100, grid:{ drawOnChartArea:false } },
          bin:{ position:'right', min:0, max:1, offset:true, grid:{ drawOnChartArea:false },
                ticks:{ stepSize:1 } }
        },
        plugins:{
          legend:{ display:false },
          annotation:{
            annotations:{
              nowline:{
                type:'line', xMin: labels[labels.length-1], xMax: labels[labels.length-1],
                borderColor:'#111', borderWidth:1.5, borderDash:[2,2],
                label:{ display:true, content:'Now', backgroundColor:'rgba(17,17,17,0.85)', color:'#fff', position:'start', yAdjust:-6 }
              }
            }
          }
        }
      }
    });

    // Checkbox show/hide
    toggles.forEach(cb => {
      const id = cb.dataset.layer;
      cb.addEventListener('change', () => {
        chart.data.datasets.forEach(d => {
          if ((id==='price' && d.yAxisID==='price' && d.label.endsWith('price'))
            || d.label === id) {
              d.hidden = !cb.checked;
          }
        });
        chart.update();
      });
    });

    // Threshold change -> recompute BIN
    controls.thInput.addEventListener('input', () => {
      localStorage.setItem(k(sym), controls.thInput.value);
      binDS.data = m2ToBin(m2, controls.thInput.value);
      // ensure BIN visibility follows its checkbox
      const binCB = Array.from(toggles).find(x => x.dataset.layer===BIN_KEY);
      binDS.hidden = binCB ? !binCB.checked : false;
      chart.update();
    });
  });
})().catch(e => console.error(e));
</script>
  <!-- m2bin-hotfix -->
  <script src="vendor/m2bin-hotfix.js"></script>
</body>
</html>
