<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Crypto scores — M1..M10 (reverted)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<style>
  :root { --fg:#0f172a; --muted:#64748b; --grid:#e5e7eb; --accent:#2563eb; }
  body{font-family: ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial;
       color:var(--fg); margin:24px; background:#fff;}
  h1{font-size:20px;margin:0 0 4px 0}
  .sub{color:var(--muted);font-size:12px;margin-bottom:14px}
  .card{border:1px solid var(--grid); border-radius:12px; padding:14px 14px 8px; margin:18px 0;}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:4px 0 10px;}
  .pill{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid var(--grid);
        border-radius:999px; background:#fff; font-size:12px}
  .pill input{transform:translateY(1px)}
  .th{margin-left:auto; color:var(--muted)}
  canvas{width:100%; height:340px}
  .foot{font-size:12px;color:var(--muted); margin-top:6px}
</style>
</head>
<body>
  <h1>Price & M-signals (48h) — reverted (M1..M10 only)</h1>
  <div class="sub">Left axis: price. Right axis: score (0–100). Hourly labels; 15‑minute ticks. Last uploaded (UTC) is read from <code>docs/data.json</code>. This version intentionally removes M2bin + threshold.</div>

  <div id="app"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
  <script>
  const SYMS = ["BTC/USDT","ETH/USDT","ONDO/USDT"];
  const PAL = ["#2563eb","#0ea5e9","#22c55e","#f59e0b","#ef4444","#8b5cf6","#14b8a6","#84cc16","#f43f5e","#a855f7"];
  const LINE_STYLE = {tension:0.25, pointRadius:0, spanGaps:true};

  function niceCard(title){
    const d = document.createElement('div'); d.className="card";
    const row = document.createElement('div'); row.className="row";
    const h = document.createElement('div'); h.textContent = title; h.style.fontWeight="600";
    row.appendChild(h);
    d.appendChild(row);
    const ctrl = document.createElement('div'); ctrl.className="row";
    d.appendChild(ctrl);
    const cv = document.createElement('canvas');
    d.appendChild(cv);
    const foot = document.createElement('div'); foot.className="foot";
    foot.textContent = "Toggle lines above. Data: docs/data.json";
    d.appendChild(foot);
    return {card:d, head:row, ctrls:ctrl, canvas:cv};
  }

  function addToggle(row, id, label, checked, onChange){
    const pill = document.createElement('label'); pill.className="pill";
    const cb = document.createElement('input'); cb.type="checkbox"; cb.checked=checked; cb.id=id;
    cb.addEventListener('change', ()=>onChange(cb.checked));
    const txt = document.createElement('span'); txt.textContent = label;
    pill.appendChild(cb); pill.appendChild(txt);
    row.appendChild(pill);
    return cb;
  }

  async function loadJSON(){
    // Try docs-local then fallback
    const urls = ["data.json", "docs/data.json"];
    for (const u of urls){
      try{
        const r = await fetch(u + "?t=" + Date.now(), {cache:"no-store"});
        if (r.ok){ return await r.json(); }
      }catch(e){/*continue*/}
    }
    throw new Error("Unable to fetch data.json");
  }

  function normKeys(obj){
    // Lowercase all signal keys e.g. M1->m1
    const out={};
    for (const [k,v] of Object.entries(obj)){
      out[k.toLowerCase()] = v;
    }
    return out;
  }

  function makeDatasets(sym, series){
    // series: { close:[], m1:[], ... m10:[] }
    const dsets=[];
    dsets.push({
      label: sym + " price",
      yAxisID:"price",
      borderColor:"#2563eb",
      backgroundColor:"#2563eb",
      data: series.close || [], ...LINE_STYLE, hidden:false
    });
    for (let i=1;i<=10;i++){
      const key = "m"+i;
      const arr = series[key];
      dsets.push({
        label: key.toUpperCase(),
        yAxisID:"score",
        borderColor: PAL[(i-1)%PAL.length],
        backgroundColor: PAL[(i-1)%PAL.length],
        borderDash: [],
        data: arr || [],
        ...LINE_STYLE,
        hidden: !arr || arr.length===0 // hide if absent
      });
    }
    return dsets;
  }

  function buildChart(ctx, labels, datasets){
    return new Chart(ctx, {
      type:"line",
      data:{ labels, datasets },
      options:{
        maintainAspectRatio:false,
        interaction:{mode:"nearest", intersect:false},
        scales:{
          x:{ type:"time",
              time:{ tooltipFormat:"HH:mm", displayFormats:{minute:"HH:mm"}},
              ticks:{ autoSkip:true, maxTicksLimit:25 }
          },
          price:{ position:"left", grid:{color:"#f3f4f6"} },
          score:{ position:"right", min:0, max:100, grid:{display:false} }
        },
        plugins:{
          legend:{ display:false }
        }
      }
    });
  }

  function attachToggles(ctrls, chart){
    // First dataset is price; next M1..M10
    const priceCB = addToggle(ctrls,"price","price",true,(on)=>{ chart.setDatasetVisibility(0,on); chart.update("none"); });
    for (let i=1;i<=10;i++){
      ((idx,label)=>{
        const dsIndex = idx; // 1..10 map to dataset index 1..10
        const exists = chart.data.datasets[dsIndex] && chart.data.datasets[dsIndex].data && chart.data.datasets[dsIndex].data.length>0;
        const cb = addToggle(ctrls, label, label, exists, (on)=>{
          chart.setDatasetVisibility(dsIndex,on);
          chart.update("none");
        });
        cb.disabled = !exists;
        if (!exists){
          cb.parentElement.title = "No data for "+label+" in data.json";
        }
      })(i, "M"+i);
    }
  }

  (async function(){
    try{
      const j = await loadJSON();
      const labels = (j.labels||[]).map(s=>new Date(s));
      const app = document.getElementById("app");

      for (const sym of SYMS){
        const card = niceCard(sym);
        app.appendChild(card.card);
        const sraw = (j.symbols && j.symbols[sym]) ? j.symbols[sym] : {};
        const s = normKeys(sraw);
        // Build datasets, then chart
        const dsets = makeDatasets(sym, s);
        const chart = buildChart(card.canvas.getContext("2d"), labels, dsets);
        attachToggles(card.ctrls, chart);
      }
    }catch(e){
      const p = document.createElement('pre');
      p.textContent = "Error loading data.json: " + e.message;
      document.body.appendChild(p);
    }
  })();
  </script>
</body>
</html>
