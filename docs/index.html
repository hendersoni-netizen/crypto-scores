<!doctype html><html><head><meta charset="utf-8"><title>Buy Scores</title>
<style>
body{font-family:-apple-system,Helvetica,Arial,sans-serif;margin:20px}
h2{margin:0 0 8px}
.status{display:flex;gap:16px;align-items:center;margin:8px 0 14px;flex-wrap:wrap}
.dot{width:10px;height:10px;border-radius:50%;background:#ef4444;box-shadow:0 0 6px #ef4444}
.kv span{font-weight:600}
table{border-collapse:collapse;width:100%;margin-top:16px}
th,td{border:1px solid #ddd;padding:6px;text-align:right}
th{text-align:center;background:#f5f5f5}
.container{max-width:1100px;margin:0 auto}
canvas{width:100%;height:420px}
.note{color:#666;font-size:12px;margin-top:6px}
</style></head><body>
<div class="container">
  <h2>Buy Scores (latest per symbol)</h2>
  <div class="status">
    <div id="statusDot" class="dot"></div>
    <div class="kv">Last run (UTC): <span id="lastRun">2025-09-10T05:49:52.240508+00:00</span></div>
    <div class="kv"><small>Uptime since last run:</small> <span id="uptime">—</span></div>
    <div class="kv"><small>Next run in (~every 15 min):</small> <span id="countdown">—</span></div>
  </div>

  <div style="margin:12px 0">
    <canvas id="scoreChart"></canvas>
    <div class="note">X axis reversed: left = 12 hours ago, right = now.</div>
  </div>

  <div id="tableWrap"><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>symbol</th>
      <th>timestamp_utc</th>
      <th>score</th>
      <th>close</th>
      <th>ema20</th>
      <th>ema50</th>
      <th>rsi</th>
      <th>macd</th>
      <th>macd_signal</th>
      <th>macd_hist</th>
      <th>bb_low</th>
      <th>bb_mid</th>
      <th>bb_high</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BTC/USDT</td>
      <td>2025-09-10T05:49:52.240508+00:00</td>
      <td>25</td>
      <td>111652.9800</td>
      <td>111485.1350</td>
      <td>111493.0617</td>
      <td>59.2857</td>
      <td>74.7024</td>
      <td>46.4805</td>
      <td>28.2220</td>
      <td>110984.6166</td>
      <td>111411.6875</td>
      <td>111838.7584</td>
    </tr>
    <tr>
      <td>ETH/USDT</td>
      <td>2025-09-10T05:49:52.240508+00:00</td>
      <td>25</td>
      <td>4317.2900</td>
      <td>4312.4698</td>
      <td>4310.5305</td>
      <td>55.3931</td>
      <td>2.4945</td>
      <td>2.6083</td>
      <td>-0.1138</td>
      <td>4297.7715</td>
      <td>4312.3850</td>
      <td>4326.9985</td>
    </tr>
    <tr>
      <td>ONDO/USDT</td>
      <td>2025-09-10T05:49:52.240508+00:00</td>
      <td>25</td>
      <td>1.0039</td>
      <td>1.0113</td>
      <td>0.9927</td>
      <td>48.7077</td>
      <td>0.0073</td>
      <td>0.0130</td>
      <td>-0.0057</td>
      <td>0.9890</td>
      <td>1.0229</td>
      <td>1.0568</td>
    </tr>
  </tbody>
</table></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<script>
const LOOKBACK_HOURS = 12;
const UI_INTERVAL_MINUTES = 15;  // for countdown text
const FRESH_MS = 10*60*1000;

const statusDot=document.getElementById('statusDot');
const lastRunEl=document.getElementById('lastRun');
const uptimeEl=document.getElementById('uptime');
const countdownEl=document.getElementById('countdown');

const ctx=document.getElementById('scoreChart').getContext('2d');
const chart=new Chart(ctx,{type:'line',data:{labels:[],datasets:[]},
  options:{responsive:true,interaction:{mode:'nearest',intersect:false},
  plugins:{legend:{position:'top'},title:{display:true,text:'Strong Buy Score (0–100) — last '+LOOKBACK_HOURS+' hours'}},
  scales:{x:{type:'time',reverse:true,time:{tooltipFormat:'HH:mm',displayFormats:{minute:'HH:mm'}},ticks:{autoSkip:true,maxTicksLimit:25}},
          y:{min:0,max:100,ticks:{stepSize:20}}}});

// --- helpers ---
function parseCSV(t){const L=t.trim().split(/\r?\n/),H=L.shift().split(',');return L.map(l=>{const C=l.split(','),o={};H.forEach((h,i)=>o[h]=C[i]);return o;});}
function fmt(ms){if(ms<0)ms=0;const s=Math.floor(ms/1000),h=String(Math.floor(s/3600)).padStart(2,'0'),m=String(Math.floor(s%3600/60)).padStart(2,'0'),x=String(s%60).padStart(2,'0');return `${h}:${m}:${x}`;}
function floor15(d){const S=900000;return new Date(Math.floor(d.getTime()/S)*S);}
function nextCountdown(){const S=900000;const n=new Date(Math.ceil(Date.now()/S)*S);return n-Date.now();} // 15-min countdown

function buildTimeline(lastUtc,hours){
  const end=new Date(lastUtc); const start=new Date(end.getTime()-hours*3600000);
  const out=[]; const step=900000;
  const alignedEnd=floor15(end);
  for(let t=floor15(start); t<=alignedEnd; t=new Date(t.getTime()+step)){ out.push(new Date(t).toISOString()); }
  return out;
}

function seriesFromRows(rows,timeline){
  const bySym={}, syms=new Set(rows.map(r=>r.symbol)); syms.forEach(s=>bySym[s]=new Array(timeline.length).fill(null));
  const idx=new Map(timeline.map((t,i)=>[t,i]));
  // sort ascending so the last write into a bucket wins
  rows.sort((a,b)=>new Date(a.timestamp_utc)-new Date(b.timestamp_utc));
  rows.forEach(r=>{
    const b=floor15(new Date(r.timestamp_utc)).toISOString();
    const i=idx.get(b); if(i===undefined) return;
    const v=parseInt(r.score,10); if(!Number.isNaN(v)) bySym[r.symbol][i]=v;
  });
  return bySym;
}

function renderTable(latestRows){
  const cols=["timestamp_utc","symbol","score","close","ema20","ema50","rsi","macd","macd_signal","macd_hist","bb_low","bb_mid","bb_high"];
  let h='<table><thead><tr>'+cols.map(c=>'<th>'+c+'</th>').join('')+'</tr></thead><tbody>';
  latestRows.forEach(r=>{h+='<tr>'+cols.map(c=>'<td>'+(r[c]??'')+'</td>').join('')+'</tr>';});
  h+='</tbody></table>'; document.getElementById('tableWrap').innerHTML=h;
}

async function loadAndUpdate(){
  try{
    const res=await fetch('buy_scores.csv?t='+Date.now(),{cache:'no-store'}); if(!res.ok) throw new Error(res.status);
    const rows=parseCSV(await res.text()); if(!rows.length) return;

    // last run & status
    const last=rows.reduce((a,r)=>a>r.timestamp_utc?a:r.timestamp_utc,rows[0].timestamp_utc);
    lastRunEl.textContent=last;
    const ms=Date.now()-new Date(last).getTime();
    const fresh=ms<FRESH_MS;
    statusDot.style.background=fresh?'#22c55e':'#ef4444';
    statusDot.style.boxShadow=fresh?'0 0 6px #22c55e':'0 0 6px #ef4444';
    uptimeEl.textContent=fmt(ms);
    countdownEl.textContent=fmt(nextCountdown());

    // table: latest per symbol
    const latest=new Map();
    rows.slice().sort((a,b)=>new Date(b.timestamp_utc)-new Date(a.timestamp_utc))
        .forEach(r=>{ if(!latest.has(r.symbol)) latest.set(r.symbol,r); });
    renderTable(Array.from(latest.values()));

    // chart series on 15-min buckets over last LOOKBACK_HOURS
    const tl=buildTimeline(last, LOOKBACK_HOURS);
    const series=seriesFromRows(rows, tl);
    chart.data.labels=tl;
    const palette=["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"];
    const syms=Object.keys(series);
    chart.data.datasets=syms.map((s,i)=>({label:s,data:series[s],borderColor:palette[i%palette.length],backgroundColor:palette[i%palette.length],spanGaps:true,tension:.25,pointRadius:0}));
    chart.update('none');
  }catch(e){ console.error(e); }
}

loadAndUpdate();
setInterval(()=>{const t=new Date(lastRunEl.textContent.trim()); if(!isNaN(t)){const ms=Date.now()-t.getTime(); uptimeEl.textContent=fmt(ms); countdownEl.textContent=fmt(nextCountdown());}},1000);
setInterval(loadAndUpdate,30000);  // poll CSV every 30s
</script></body></html>