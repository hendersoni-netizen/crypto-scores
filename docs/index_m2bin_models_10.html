<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Probe — M1..M10 + M2bin (fixed sizing)</title>
  <style>
    :root{--card-w:1100px;--card-h:360px;}
    body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;background:#fafafa;color:#111;}
    h1{font-size:18px;margin:0 0 12px;}
    .meta{font-size:12px;color:#666;margin-bottom:12px;}
    .grid{display:flex;flex-direction:column;gap:18px;align-items:flex-start}
    .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 1px 2px rgba(0,0,0,.04);padding:12px;width:var(--card-w);}
    .card .head{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
    .toggles{display:flex;gap:8px;flex-wrap:wrap;align-items:center;font-size:12px}
    .toggles label{display:inline-flex;align-items:center;gap:4px;padding:2px 6px;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb}
    .chart-wrap{position:relative;height:var(--card-h);}
    /* Force canvas height (fix “very tall” bug) */
    .chart-wrap canvas{position:absolute;inset:0;height:100% !important;width:100% !important;max-height:100% !important;}
    .note{font-size:12px;color:#777;margin-top:6px}
    .thresh{display:inline-flex;align-items:center;gap:6px;margin-left:10px}
    .thresh input{width:52px;padding:2px 6px;border:1px solid #d1d5db;border-radius:6px}
  </style>
</head>
<body>
  <h1>Price & M‑signals (48h) — fixed size + axis mapping</h1>
  <div class="meta">Left axis: price. Right axis: score (0–100). Hourly labels. 15‑minute ticks.</div>
  <div class="grid" id="grid"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
  <script>
  const MODELS = Array.from({length:10},(_,i)=>'M'+(i+1));
  const COLORS = {
    price:'#2563eb',
    M1:'#0ea5e9', M2:'#22c55e', M3:'#84cc16', M4:'#a855f7', M5:'#ec4899',
    M6:'#14b8a6', M7:'#f97316', M8:'#eab308', M9:'#ef4444', M10:'#64748b',
    M2bin:'#111111'
  };

  function el(tag, attrs={}, children=[]) {
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v])=> e.setAttribute(k, v));
    (Array.isArray(children)?children:[children]).forEach(c=> e.append(c));
    return e;
  }

  function makeCard(symbol){
    const card = el('div',{class:'card'});
    const head = el('div',{class:'head'});
    const title = el('div',{style:'font-weight:600'}, symbol);
    // Controls
    const ctrl = el('div',{class:'toggles'});
    const mkToggle = (id, text, checked=true, disabled=false)=>{
      const lbl = el('label');
      const cb = el('input',{type:'checkbox', id:id});
      if(checked) cb.checked = true;
      if(disabled) cb.disabled = true;
      lbl.append(cb, text);
      ctrl.append(lbl);
      return cb;
    };
    const priceCb = mkToggle(symbol+'_price', 'price', true, false);
    const modelCbs = {};
    MODELS.forEach(m => { modelCbs[m] = mkToggle(symbol+'_'+m, m, (m==='M2')); });
    const binCb = mkToggle(symbol+'_M2bin', 'M2bin', true, false);
    const thresh = el('span',{class:'thresh'});
    thresh.append('M2 threshold:', el('input',{type:'number', id:symbol+'_th', min:'0', max:'100', step:'1', value:'50'}));
    ctrl.append(thresh);
    head.append(title, ctrl);
    card.append(head);
    // Chart container
    const wrap = el('div',{class:'chart-wrap'});
    const canvas = el('canvas',{id:'cv_'+symbol});
    wrap.append(canvas);
    card.append(wrap);
    // Note
    const note = el('div',{class:'note'},'Dashed black = M2bin (0/100) using threshold.');
    card.append(note);
    return {card, priceCb, modelCbs, binCb, canvas};
  }

  function seriesFor(labels, arr){
    // Ensure same length as labels; use nulls when missing
    const out = new Array(labels.length).fill(null);
    if(Array.isArray(arr)){
      const n = Math.min(labels.length, arr.length);
      for(let i=0;i<n;i++) out[i] = arr[i];
    }
    return out;
  }

  fetch('data.json?t='+Date.now(), {cache:'no-store'}).then(r=>r.json()).then(({labels, symbols})=>{
    const grid = document.getElementById('grid');
    const lastUTC = labels[labels.length-1] || '';
    // Build per‑symbol card
    Object.keys(symbols).forEach(sym => {
      const {card, priceCb, modelCbs, binCb, canvas} = makeCard(sym);
      grid.append(card);
      const s = symbols[sym] || {};
      const price = seriesFor(labels, s.close);
      const ms = {};
      MODELS.forEach(m => ms[m] = seriesFor(labels, (s[m] || s[m.toLowerCase()] || [])));
      // Disable toggles that don’t exist (all nulls)
      MODELS.forEach(m => {
        const hasAny = ms[m].some(v=>v!==null && v!==undefined);
        if(!hasAny) { const cb = document.getElementById(sym+'_'+m); cb.disabled = true; cb.checked = false; }
      });

      // Build chart
      const ctx = canvas.getContext('2d');
      const chart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false, // respect container size (fixed by CSS)
          animation: false,
          interaction: { mode: 'nearest', intersect: false },
          plugins: {
            legend: { display: true, position: 'top' }
          },
          scales: {
            x: { type: 'time', time:{ tooltipFormat:'yyyy-MM-dd HH:mm' }, ticks:{ source:'auto' } },
            price: { position:'left', grid:{ color:'rgba(0,0,0,0.05)'}, ticks:{ callback:(v)=>v } },
            score: { position:'right', min:0, max:100, grid:{ drawOnChartArea:false }, ticks:{ stepSize:20 } }
          }
        }
      });

      function rebuild(){
        const th = Math.max(0, Math.min(100, Number(document.getElementById(sym+'_th').value || 50)));
        const ds = [];
        if(priceCb.checked){
          ds.push({
            label: sym + ' price',
            data: price,
            yAxisID: 'price',
            borderColor: COLORS.price,
            backgroundColor: COLORS.price,
            pointRadius: 0,
            tension: .25
          });
        }
        MODELS.forEach(m => {
          const cb = document.getElementById(sym+'_'+m);
          if(cb && cb.checked && !cb.disabled){
            ds.push({
              label: m,
              data: ms[m],
              yAxisID: 'score',
              borderColor: COLORS[m],
              backgroundColor: COLORS[m],
              pointRadius: 0,
              tension: .25,
              spanGaps: true
            });
          }
        });
        if(binCb.checked){
          // Compute binary from M2
          const m2 = ms['M2'];
          const bin = m2.map(v => (v==null ? null : (v >= th ? 100 : 0)));
          ds.push({
            label: 'M2bin',
            data: bin,
            yAxisID: 'score',
            borderColor: COLORS.M2bin,
            borderDash: [6,4],
            pointRadius: 0,
            tension: 0,
            spanGaps: true
          });
        }
        chart.data.datasets = ds;
        chart.update('none');
      }

      // Wire controls
      priceCb.addEventListener('change', rebuild);
      Object.keys(modelCbs).forEach(m => (document.getElementById(sym+'_'+m)||{}).addEventListener?.('change', rebuild));
      binCb.addEventListener('change', rebuild);
      document.getElementById(sym+'_th').addEventListener('input', rebuild);

      rebuild();
    });
  }).catch(e=>{
    document.body.append('Failed to load data.json: ', e);
  });
  </script>
</body>
</html>
